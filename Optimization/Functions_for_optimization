## FUNCTIONS 

def generate_sat_orbits(altitudes, sat_distribution):
    """
    Generate satellite orbits based on altitudes and satellite distribution.

    Args:
        altitudes: List of altitudes for each orbital plane (in km).
        sat_distribution: List of the number of satellites assigned to each orbital plane.

    Returns:
        sat_orbits: List of satellite orbits (poliastro Orbit objects).
    """
    sat_orbits = []
    num_planes = len(altitudes)  # Number of orbital planes
    raan_spacing = 360 / num_planes  # Spacing in RAAN between planes

    for i in range(num_planes):
        raan = i * raan_spacing * u.deg  # RAAN for the current plane
        altitude = altitudes[i]  # Altitude of the current plane
        num_sats = sat_distribution[i]  # Number of satellites in the current plane

        for j in range(num_sats):
            true_anomaly = j * (360 / num_sats) * u.deg  # Spacing satellites evenly in the plane
            orbit = Orbit.from_classical(
                Earth,
                Earth.R + altitude * u.km,  # Semi-major axis (altitude above Earth's radius)
                0 * u.one,  # Eccentricity
                90 * u.deg,  # Inclination (defaulting to polar orbit, can be adjusted if needed)
                raan,  # Right Ascension of Ascending Node
                0 * u.deg,  # Argument of Periapsis
                true_anomaly,  # True Anomaly
            )
            sat_orbits.append(orbit)

    return sat_orbits


def constellation_efficiency(params, debris_orbits, total_particles):
    """
    Evaluate the efficiency of a satellite constellation in observing debris.

    Args:
        params: A tuple containing:
            - altitudes: List of altitudes for each orbital plane (in km).
            - sat_distribution: List of the number of satellites assigned to each orbital plane.
        debris_orbits: List of debris orbits (poliastro Orbit objects).
        total_particles: Total number of debris particles.

    Returns:
        Detection efficiency: Ratio of observed debris to total debris.
    """
    altitudes = params[0]  # List of altitudes for each orbital plane
    sat_distribution = params[1]  # Number of satellites assigned to each altitude

    # Generate satellite orbits for the constellation
    sat_orbits = generate_sat_orbits(altitudes, sat_distribution)
    total_sats = sum(sat_distribution)  # Ensure consistency with the total satellite count

    # Initialize debris and satellite positions
    obs_deb = []  # List to track observed debris
    position_deb = np.zeros((total_particles, 3))
    position_sat = np.zeros((total_sats, 3))

    # Loop over time points
    for t in time_points:
        print(f"time {t / (3600 * u.s)} h")  # Print time in hours for debugging

        # Propagate debris positions
        for i, orbit_deb in enumerate(debris_orbits):
            state_deb = orbit_deb.propagate(t)
            position_deb[i] = state_deb.represent_as(CartesianRepresentation).xyz.to_value(u.km)

        # Propagate satellite positions
        for i, orbit_sat in enumerate(sat_orbits):
            state_sat = orbit_sat.propagate(t)
            position_sat[i] = state_sat.represent_as(CartesianRepresentation).xyz.to_value(u.km)

        # Check for debris detection
        for sat in range(total_sats):
            radar_direction = position_sat[sat] / np.linalg.norm(position_sat[sat])
            for deb in range(total_particles):
                rel_position = position_sat[sat] - position_deb[deb]
                dist = np.linalg.norm(rel_position)

                # Check range and field of view
                ran = 1 if dist < max_range else 0
                cos_angle = np.dot(rel_position / dist, radar_direction)
                angle = np.arccos(cos_angle) * (180 / np.pi)
                fov = 1 if angle < FOV else 0

                if fov * ran == 1:  # If debris is detected
                    obs_deb.append(deb)

    # Calculate detection efficiency
    obs_deb = np.unique(obs_deb)
    return len(obs_deb) / total_particles


def particle_swarm_optimization(
    objective, bounds, num_particles, num_iterations, debris_orbits, total_particles, fixed_total_sats
):
    """
    PSO for optimizing orbital parameters with variable altitudes and satellite distribution.
    """
    num_planes = 12  # Start with 12 orbital planes
    initial_altitudes = np.linspace(bounds[0, 0], bounds[0, 1], num_planes)  # Evenly spaced altitudes
    initial_satellites = np.full(num_planes, fixed_total_sats // num_planes)  # Equal satellites per plane

    # Initialize particles
    particles = []
    for _ in range(num_particles):
        altitudes = initial_altitudes + np.random.uniform(-10, 10, num_planes)  # Small initial variation
        satellite_distribution = np.random.dirichlet(np.ones(num_planes)) * fixed_total_sats
        satellite_distribution = np.round(satellite_distribution).astype(int)
        satellite_distribution[-1] += fixed_total_sats - np.sum(satellite_distribution)  # Fix rounding errors
        particles.append((altitudes, satellite_distribution))

    velocities = [np.zeros_like(particle[0]) for particle in particles]  # Zero velocities for altitudes
    personal_best_positions = particles.copy()
    personal_best_scores = np.full(num_particles, -np.inf)
    global_best_position = None
    global_best_score = -np.inf

    # Real-time plotting setup
    plt.ion()
    fig, ax = plt.subplots()

    for iteration in range(num_iterations):
        scores = []

        for i, (altitudes, satellite_distribution) in enumerate(particles):
            # Evaluate objective function
            params = (altitudes, satellite_distribution)
            score = objective(params, debris_orbits, total_particles)
            scores.append(score)

            # Update personal best
            if score > personal_best_scores[i]:
                personal_best_scores[i] = score
                personal_best_positions[i] = (altitudes.copy(), satellite_distribution.copy())

            # Update global best
            if score > global_best_score:
                global_best_score = score
                global_best_position = (altitudes.copy(), satellite_distribution.copy())

        # Update velocities and positions
        inertia = 0.5
        cognitive = 2
        social = 2

        for j, (altitudes, satellite_distribution) in enumerate(particles):
            r1, r2 = np.random.rand(2)

            # Update velocities for altitudes
            velocities[j] = (
                inertia * velocities[j]
                + cognitive * r1 * (personal_best_positions[j][0] - altitudes)
                + social * r2 * (global_best_position[0] - altitudes)
            )
            altitudes += velocities[j]

            # Ensure altitudes stay within bounds
            altitudes = np.clip(altitudes, bounds[0, 0], bounds[0, 1])

            # Adjust satellite distribution (stochastic perturbation)
            satellite_distribution += np.random.randint(-1, 2, len(satellite_distribution))
            satellite_distribution = np.clip(satellite_distribution, 0, fixed_total_sats)
            satellite_distribution[-1] += fixed_total_sats - np.sum(satellite_distribution)  # Fix total count

            particles[j] = (altitudes, satellite_distribution)

        # Real-time plot
        ax.clear()
        ax.set_xlim(bounds[0, 0], bounds[0, 1])  # Altitude range
        ax.set_ylim(0, fixed_total_sats)  # Satellites per altitude range
        ax.set_title(f"Iteration {iteration + 1}")
        ax.set_xlabel("Altitude (km)")
        ax.set_ylabel("Number of Satellites")
        print(f"global best score: {global_best_score}")

        # Plot current particles
        for altitudes, satellite_distribution in particles:
            ax.scatter(altitudes, satellite_distribution, color="blue", alpha=0.5)

        plt.pause(0.1)

    plt.ioff()
    plt.show()

    return global_best_position, global_best_score




## CALLING THE FUNCTION
bounds = np.array([
    [450, 1350],    # Altitude range (km)
    [5, 15],       # Number of orbital planes
])
global_best_position = np.zeros(len(bounds))

num_particles = 3
num_iterations = 25

best_params, best_score = particle_swarm_optimization(constellation_efficiency, bounds, num_particles, num_iterations, debris_orbits, total_particles, fixed_total_sats=48)

print("Best Parameters:", best_params)
print("Best Detection Efficiency:", best_score)
